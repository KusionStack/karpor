package uniresource

import (
	"context"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/klog/v2"

	"github.com/dominikbraun/graph"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/dynamic"
)

// GetParentResourcesList returns an *unstructured.UnstructuredList representing all resources that matches the parent GVK in the current namespace
func GetParentResourcesList(ctx context.Context, client *dynamic.DynamicClient, parentRelation *Relationship, namespace string) (*unstructured.UnstructuredList, error) {
	gv, _ := schema.ParseGroupVersion(parentRelation.Group + "/" + parentRelation.Version)
	gvk := gv.WithKind(parentRelation.Kind)
	mapper := meta.NewDefaultRESTMapper([]schema.GroupVersion{})
	scope := Scope{meta.RESTScopeNameNamespace}
	mapper.Add(gvk, scope)
	mapping, err := mapper.RESTMapping(schema.GroupKind{Group: gv.Group, Kind: parentRelation.Kind}, gv.Version)
	if err != nil {
		return nil, err
	}
	parentRes := mapping.Resource
	klog.Infof("Listing parent resource %s in namespace %s: \n", parentRelation.Kind, namespace)
	var parentResList *unstructured.UnstructuredList
	// Depends on whether parent object is namespaced or not
	// TODO-think: Can this be derived from discovery.ServerResourcesForGroupVersion(version)?
	// TODO-think: Can this be retrieved from storage instead directly from cluster?
	if parentRelation.ClusterScoped {
		parentResList, err = client.Resource(parentRes).List(ctx, metav1.ListOptions{})
	} else {
		parentResList, err = client.Resource(parentRes).Namespace(namespace).List(ctx, metav1.ListOptions{})
	}
	if err != nil {
		return nil, err
	}
	if parentResList != nil {
		klog.Infof("List return size: %d\n", len(parentResList.Items))
	}
	return parentResList, nil
}

// GetParents returns a graph that includes all of the parent resources for the current obj that are described by the parentRelation
func GetParents(ctx context.Context, client *dynamic.DynamicClient, obj unstructured.Unstructured, parentRelation *Relationship, namespace, objName string, objResourceNode ResourceGraphNode, relationshipGraph graph.Graph[string, RelationshipGraphNode], resourceGraph graph.Graph[string, ResourceGraphNode]) (graph.Graph[string, ResourceGraphNode], error) {
	var err error
	if parentRelation.Type == "OwnerReference" {
		// If relationship type is ownerreference, honor that instead of relationship graph
		resourceGraph, err = GetParentsByOwnerReference(ctx, client, obj, objResourceNode, relationshipGraph, resourceGraph)
		if err != nil {
			return nil, err
		}
	} else {
		gv, _ := schema.ParseGroupVersion(parentRelation.Group + "/" + parentRelation.Version)
		gvk := gv.WithKind(parentRelation.Kind)
		parentResList, err := GetParentResourcesList(ctx, client, parentRelation, namespace)
		if errors.IsNotFound(err) {
			klog.Infof("Obj %s in namespace %s not found\n", objName, namespace)
		} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
			klog.Infof("Error getting obj %s in namespace %s: %v\n", objName, namespace, statusError.ErrStatus.Message)
		} else if err != nil {
			return nil, err
		} else if len(parentResList.Items) > 0 {
			if parentRelation.Type == "JSONPath" {
				resourceGraph, err = GetParentsByJSONPath(parentResList, ctx, client, obj, parentRelation, gvk, objResourceNode, relationshipGraph, resourceGraph)
				if err != nil {
					return nil, err
				}
			} else if parentRelation.Type == "Selector" {
				resourceGraph, err = GetParentsByLabelSelector(parentResList, ctx, client, obj, parentRelation, gvk, objResourceNode, relationshipGraph, resourceGraph)
				if err != nil {
					return nil, err
				}
			} else {
				klog.Infof("Something went wrong. Type should be either OwnerReference, Selector, or JSONPath")
			}
		}
	}
	return resourceGraph, nil
}

// GetParentsByJSONPath returns a graph that includes all of the parent resources for the current obj that are described by the JSONPath type parentRelation
func GetParentsByJSONPath(parentResList *unstructured.UnstructuredList, ctx context.Context, client *dynamic.DynamicClient, obj unstructured.Unstructured, parentRelation *Relationship, parentGVK schema.GroupVersionKind, objResourceNode ResourceGraphNode, relationshipGraph graph.Graph[string, RelationshipGraphNode], resourceGraph graph.Graph[string, ResourceGraphNode]) (graph.Graph[string, ResourceGraphNode], error) {
	klog.Infof("Using direct references to find parents...\n")
	var jpMatch bool
	var err error
	for _, parentRes := range parentResList.Items {
		if parentRelation.AutoGenerated {
			jpMatch, err = JSONPathMatch(parentRes, obj, parentRelation.JSONPath)
		} else {
			jpMatch, err = JSONPathMatch(obj, parentRes, parentRelation.JSONPath)
		}
		if jpMatch && err == nil {
			klog.Infof("Parent resource found for kind %s, name %s based on JSONPath.\n", obj.GetKind(), obj.GetName())
			klog.Infof("Parent resource is: kind %s, name %s.\n", parentRes.GetKind(), parentRes.GetName())
			klog.Infof("---------------------------------------------------------------------------\n")
			pgv, _ := schema.ParseGroupVersion(parentRes.GetAPIVersion())
			parentResourceNode := ResourceGraphNode{
				Group:     pgv.Group,
				Version:   pgv.Version,
				Kind:      parentRes.GetKind(),
				Name:      parentRes.GetName(),
				Namespace: parentRes.GetNamespace(),
			}
			resourceGraph.AddVertex(parentResourceNode)
			resourceGraph.AddEdge(parentResourceNode.GetHash(), objResourceNode.GetHash())
			parentGVKOnGraph, _ := FindNodeOnGraph(relationshipGraph, parentGVK.Group, parentGVK.Version, parentGVK.Kind)
			if len(parentGVKOnGraph.Parent) > 0 {
				for _, parentRelation := range parentGVKOnGraph.Parent {
					resourceGraph, _ = GetParents(ctx, client, parentRes, parentRelation, parentRes.GetNamespace(), parentRes.GetName(), parentResourceNode, relationshipGraph, resourceGraph)
				}
			}
		}
	}
	return resourceGraph, nil
}

// GetParentsByLabelSelector returns a graph that includes all of the parent resources for the current obj that are described by the LabelSelector type parentRelation
func GetParentsByLabelSelector(parentResList *unstructured.UnstructuredList, ctx context.Context, client *dynamic.DynamicClient, obj unstructured.Unstructured, parentRelation *Relationship, parentGVK schema.GroupVersionKind, objResourceNode ResourceGraphNode, relationshipGraph graph.Graph[string, RelationshipGraphNode], resourceGraph graph.Graph[string, ResourceGraphNode]) (graph.Graph[string, ResourceGraphNode], error) {
	klog.Infof("Using label selectors to find parents...\n")
	for _, parentRes := range parentResList.Items {
		if labelsMatch, err := LabelSelectorsMatch(parentRes, obj, parentRelation.SelectorPath); labelsMatch && err == nil {
			klog.Infof("Parent resource found for kind %s, name %s based on %s.\n", obj.GetKind(), obj.GetName(), parentRelation.SelectorPath)
			klog.Infof("Parent resource is: kind %s, name %s.\n", parentRes.GetKind(), parentRes.GetName())
			klog.Infof("---------------------------------------------------------------------------\n")
			pgv, _ := schema.ParseGroupVersion(parentRes.GetAPIVersion())
			parentResourceNode := ResourceGraphNode{
				Group:     pgv.Group,
				Version:   pgv.Version,
				Kind:      parentRes.GetKind(),
				Name:      parentRes.GetName(),
				Namespace: parentRes.GetNamespace(),
			}
			resourceGraph.AddVertex(parentResourceNode)
			resourceGraph.AddEdge(parentResourceNode.GetHash(), objResourceNode.GetHash())
			parentGVKOnGraph, _ := FindNodeOnGraph(relationshipGraph, parentGVK.Group, parentGVK.Version, parentGVK.Kind)
			if len(parentGVKOnGraph.Parent) > 0 {
				for _, parentRelation := range parentGVKOnGraph.Parent {
					resourceGraph, _ = GetParents(ctx, client, parentRes, parentRelation, parentRes.GetNamespace(), parentRes.GetName(), parentResourceNode, relationshipGraph, resourceGraph)
				}
			}
		}
	}
	return resourceGraph, nil
}

// GetParentsByOwnerReference returns a graph that includes all of the parent resources for the current obj described by its OwnerReferences field
func GetParentsByOwnerReference(ctx context.Context, client *dynamic.DynamicClient, obj unstructured.Unstructured, objResourceNode ResourceGraphNode, relationshipGraph graph.Graph[string, RelationshipGraphNode], resourceGraph graph.Graph[string, ResourceGraphNode]) (graph.Graph[string, ResourceGraphNode], error) {
	klog.Infof("Using OwnerReferences to find parents...\n")
	objName := obj.GetName()
	namespace := obj.GetNamespace()
	objOwnerList := obj.GetOwnerReferences()
	var objOwner metav1.OwnerReference
	if len(objOwnerList) == 1 {
		objOwner = objOwnerList[0]
	} else if len(objOwnerList) == 0 {
		klog.Infof("No owner found for kind %s, name %s\n", obj.GetKind(), obj.GetName())
		return resourceGraph, nil
	} else {
		klog.Infof("Found more than 1 owner.")
		return resourceGraph, nil
	}

	gv, _ := schema.ParseGroupVersion(objOwner.APIVersion)
	gvk := gv.WithKind(objOwner.Kind)

	mapper := meta.NewDefaultRESTMapper([]schema.GroupVersion{})
	scope := Scope{"namespace"}
	mapper.Add(gvk, scope)
	mapping, err := mapper.RESTMapping(schema.GroupKind{Group: gv.Group, Kind: objOwner.Kind}, gv.Version)
	if err != nil {
		return nil, err
	}
	parentRes := mapping.Resource

	klog.Infof("Listing parent resource %s in namespace %s: \n", objOwner.Kind, namespace)
	parentResList, err := client.Resource(parentRes).Namespace(namespace).List(ctx, metav1.ListOptions{})
	if errors.IsNotFound(err) {
		klog.Infof("Obj %s in namespace %s not found\n", objName, namespace)
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		klog.Infof("Error getting obj %s in namespace %s: %v\n", objName, namespace, statusError.ErrStatus.Message)
	} else if err != nil {
		return nil, err
	} else if len(parentResList.Items) > 0 {
		for _, parentRes := range parentResList.Items {
			if parentRes.GetUID() == objOwner.UID {
				klog.Infof("Parent resource found for kind %s, name %s based on OwnerReference. \n", obj.GetKind(), objName)
				klog.Infof("Parent resource is: kind %s, name %s.\n", parentRes.GetKind(), parentRes.GetName())
				klog.Infof("---------------------------------------------------------------------------\n")
				pgv, _ := schema.ParseGroupVersion(parentRes.GetAPIVersion())
				parentResourceNode := ResourceGraphNode{
					Group:     pgv.Group,
					Version:   pgv.Version,
					Kind:      parentRes.GetKind(),
					Name:      parentRes.GetName(),
					Namespace: parentRes.GetNamespace(),
				}
				resourceGraph.AddVertex(parentResourceNode)
				resourceGraph.AddEdge(parentResourceNode.GetHash(), objResourceNode.GetHash())
				if len(parentRes.GetOwnerReferences()) > 0 {
					resourceGraph, _ = GetParentsByOwnerReference(ctx, client, parentRes, parentResourceNode, relationshipGraph, resourceGraph)
				}
			}
		}
	}
	return resourceGraph, nil
}
