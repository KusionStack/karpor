/*
Copyright The Karbour Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package uniresource

import (
	"context"
	"fmt"
	"os"
	"reflect"
	"strings"

	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/klog/v2"

	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
	"github.com/pkg/errors"
	yaml "gopkg.in/yaml.v3"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/dynamic"

	cluster "github.com/KusionStack/karbour/pkg/apis/cluster"
	clusterstorage "github.com/KusionStack/karbour/pkg/registry/cluster"
	filtersutil "github.com/KusionStack/karbour/pkg/util/filters"
	"github.com/oliveagle/jsonpath"
)

type RelationshipGraph struct {
	RelationshipNodes []*RelationshipGraphNode `json:"relationship,omitempty" yaml:"relationship,omitempty"`
}

type RelationshipGraphNode struct {
	Group    string          `json:"group,omitempty" yaml:"group,omitempty"`
	Version  string          `json:"version,omitempty" yaml:"version,omitempty"`
	Kind     string          `json:"kind,omitempty" yaml:"kind,omitempty"`
	Parent   []*Relationship `json:"parent,omitempty" yaml:"parent,omitempty"`
	Children []*Relationship `json:"children,omitempty" yaml:"children,omitempty"`
}

type Relationship struct {
	ParentNode    *RelationshipGraphNode
	ChildNode     *RelationshipGraphNode
	AutoGenerated bool
	Group         string              `json:"group,omitempty" yaml:"group,omitempty"`
	Version       string              `json:"version,omitempty" yaml:"version,omitempty"`
	Kind          string              `json:"kind,omitempty" yaml:"kind,omitempty"`
	ClusterScoped bool                `json:"clusterScoped,omitempty" yaml:"cluster_scoped,omitempty"`
	Type          string              `json:"type,omitempty" yaml:"type,omitempty"`
	SelectorPath  string              `json:"selectorPath,omitempty" yaml:"selector_path,omitempty"`
	JSONPath      []map[string]string `json:"jsonPath,omitempty" yaml:"json_path,omitempty"`
}

type ResourceGraphNode struct {
	Name      string
	Namespace string
	Group     string
	Version   string
	Kind      string
	Parent    []*ResourceGraphNode
	Children  []*ResourceGraphNode
}

func (r ResourceGraphNode) GetHash() string {
	return r.Group + "/" + r.Version + "." + r.Kind + ":" + r.Namespace + "." + r.Name
}

func (r RelationshipGraphNode) GetHash() string {
	return r.Group + "." + r.Version + "." + r.Kind
}

// FindNodeByGVK locates the Node by GVK on a RelationshipGraph. Used to locate parent and child nodes when building the relationship graph
func FindNodeByGVK(rg RelationshipGraph, group, version, kind string) (*RelationshipGraphNode, error) {
	for _, item := range rg.RelationshipNodes {
		if item.Group == group && item.Version == version && item.Kind == kind {
			return item, nil
		}
	}
	// If not found, return a new one so it can be inserted properly
	r := RelationshipGraphNode{
		Group:    group,
		Version:  version,
		Kind:     kind,
		Parent:   make([]*Relationship, 0),
		Children: make([]*Relationship, 0),
	}
	nodeNotFoundErr := fmt.Errorf("node not found by GVK: Group: %s, Version: %s, Kind: %s", group, version, kind)
	return &r, nodeNotFoundErr
}

// FindNodeOnGraph locates the Node on a built relationship graph. Used to locate parent and child nodes when traversing the relationship graph
func FindNodeOnGraph(g graph.Graph[string, RelationshipGraphNode], group, version, kind string) (*RelationshipGraphNode, error) {
	klog.Infof("Locating node on relationship graph: Group: %s, Version: %s, Kind: %s\n", group, version, kind)
	vertexHash := group + "." + version + "." + kind
	vertex, err := g.Vertex(vertexHash)
	if err != nil {
		return nil, err
	}
	return &vertex, nil
}

// IsMapSubset returns true if sub is a subnet of m
func IsMapSubset[K, V comparable](m, sub map[K]V) bool {
	if len(sub) > len(m) {
		return false
	}
	for k, vsub := range sub {
		if vm, found := m[k]; !found || vm != vsub {
			return false
		}
	}
	return true
}

// OwnerReferencesMatch returns true if parent is in the child's ownerReferences field
func OwnerReferencesMatch(parent, child unstructured.Unstructured) (bool, error) {
	ownerReferences := child.GetOwnerReferences()
	for _, owner := range ownerReferences {
		if owner.UID == parent.GetUID() {
			return true, nil
		}
	}
	return false, nil
}

// LabelSelectorsMatch returns true if the labels set in selectorPath in the selectorObj can select selectedObj
func LabelSelectorsMatch(selectorObj, selectedObj unstructured.Unstructured, selectorPath string) (bool, error) {
	selectorSplit := strings.Split(selectorPath, ".")
	selectors, _, _ := unstructured.NestedStringMap(selectorObj.Object, selectorSplit...)
	if len(selectors) == 0 {
		return false, fmt.Errorf("shouldn't have empty selector and a selector type relationship")
	}
	labels := selectedObj.GetLabels()
	return IsMapSubset(labels, selectors), nil
}

// JSONPathMatch returns true if source.criteriaKey(name/namespace) matches target.criteriaValue(JSONPath)
// criteriaSet contains a list of map from criteriaKey to criteriaValue
// Returns true if either map returns a full match based on length of the map
func JSONPathMatch(source, target unstructured.Unstructured, criteriaSet []map[string]string) (bool, error) {
	criteriaMatchCount := 0
	for _, criteriaMap := range criteriaSet {
		for criteriaKey, criteriaValue := range criteriaMap {
			targetValue, _ := GetNestedValue(target, criteriaValue)
			sourceValue := ""
			if criteriaKey == "name" {
				// match name
				sourceValue = source.GetName()
			} else if criteriaKey == "namespace" {
				// match namespace
				sourceValue = source.GetNamespace()
			} else {
				// shouldn't be anything else
				return false, fmt.Errorf("shouldn't have anything other than name or namespace")
			}
			// If targetValue is an array
			if reflect.TypeOf(targetValue).Kind() == reflect.Slice {
				// If any of the elements in the targetValue slice matches sourceValue, consider it a match
				// Example: If the secret name appears in the list of $.spec.volumes[:].secret.secretName
				for i := 0; i < reflect.ValueOf(targetValue).Len(); i++ {
					if reflect.ValueOf(targetValue).Index(i).Interface().(string) == sourceValue {
						criteriaMatchCount++
					}
				}
			} else if reflect.TypeOf(targetValue).Kind() == reflect.String {
				if sourceValue == targetValue {
					criteriaMatchCount++
				}
			}
		}
		// Only returns match if all of the matching criteria in the map are true
		if criteriaMatchCount == len(criteriaMap) {
			klog.Infof("Found a match based on JSONPath!")
			return true, nil
		}
	}
	return false, nil
}

// GetNestedValue returns nested value from the JSONPath obj.criteria
func GetNestedValue(obj unstructured.Unstructured, criteria string) (interface{}, error) {
	pat := jsonpath.MustCompile(criteria)
	res, err := pat.Lookup(obj.Object)
	if err != nil {
		return "", err
	}
	return res, nil
}

// BuildBuiltinRelationshipGraph returns the relationship graph built from the YAML describing resource relationships
func BuildBuiltinRelationshipGraph() (graph.Graph[string, RelationshipGraphNode], error) {
	r := RelationshipGraph{}
	yamlFile, err := os.ReadFile("relationship.yaml")
	if err != nil {
		klog.Infof("yamlFile.Get err #%v ", err)
	}
	err = yaml.Unmarshal(yamlFile, &r)
	if err != nil {
		klog.Fatalf("Unmarshal: %v", err)
	}

	// Process relationships between parent and child
	// TODO: Think about whether two-way relationship need to be enforced and explicitly declared.
	// Right now they are automatically derived
	for _, ri := range r.RelationshipNodes {
		for _, c := range ri.Children {
			c.ParentNode = ri
			c.ChildNode, err = FindNodeByGVK(r, c.Group, c.Version, c.Kind)
			if err != nil {
				r.RelationshipNodes = append(r.RelationshipNodes, c.ChildNode)
			}
			// Append the same parent-child relationship to child's parent node if it does not exist already
			c.ChildNode.Parent, err = InsertIfNotExist(c.ChildNode.Parent, *c, "parent")
			if err != nil {
				return nil, err
			}
		}
		for _, p := range ri.Parent {
			p.ChildNode = ri
			p.ParentNode, err = FindNodeByGVK(r, p.Group, p.Version, p.Kind)
			if err != nil {
				r.RelationshipNodes = append(r.RelationshipNodes, p.ParentNode)
			}
			// Append the same parent-child relationship to parent's child node if it does not exist already
			p.ParentNode.Children, err = InsertIfNotExist(p.ParentNode.Children, *p, "child")
			if err != nil {
				return nil, err
			}
		}
	}

	// Initialize the relationship graph based on GVK
	relationshipGraphNodeHash := func(rgn RelationshipGraphNode) string {
		return rgn.Group + "." + rgn.Version + "." + rgn.Kind
	}
	g := graph.New(relationshipGraphNodeHash, graph.Directed(), graph.PreventCycles())
	// Add Vertices
	for _, node := range r.RelationshipNodes {
		klog.Infof("Adding Vertex: %s\n", node.GetHash())
		_ = g.AddVertex(*node)
	}
	// Add Edges, requires all vertices to be present
	for _, node := range r.RelationshipNodes {
		for _, child := range node.Children {
			klog.Infof("Adding or updating Edge from %s to %s with type %s\n", node.GetHash(), child.ChildNode.GetHash(), child.Type)
			if err := g.AddEdge(node.GetHash(), child.ChildNode.GetHash(), graph.EdgeAttribute("type", child.Type)); err != graph.ErrEdgeAlreadyExists && err != nil {
				panic(err)
			}
		}
		// Prevent duplicate edge
		for _, parentRelation := range node.Parent {
			klog.Infof("Adding or updating Edge from %s to %s with type %s\n", parentRelation.ParentNode.GetHash(), node.GetHash(), parentRelation.Type)
			if err := g.AddEdge(parentRelation.ParentNode.GetHash(), node.GetHash(), graph.EdgeAttribute("type", parentRelation.Type)); err != graph.ErrEdgeAlreadyExists && err != nil {
				panic(err)
			}
		}
	}

	klog.Infof("Built-in graph completed.")

	// Draw graph
	file, _ := os.Create("./relationship.gv")
	_ = draw.DOT(g, file)

	return g, nil
}

// BuildResourceRelationshipGraph builds the complete relationship graph including the built-in one and customer-specified one
func BuildResourceRelationshipGraph() (graph.Graph[string, RelationshipGraphNode], error) {
	res, _ := BuildBuiltinRelationshipGraph()
	// TODO: Also include customized relationship graph
	return res, nil
}

// BuildDynamicClient returns a dynamic client based on the cluster name in the request
func (r *REST) BuildDynamicClient(ctx context.Context) (*dynamic.DynamicClient, error) {
	// Extract the cluster name from context
	resourceDetail, ok := filtersutil.ResourceDetailFrom(ctx)
	if !ok {
		return nil, fmt.Errorf("name, namespace, cluster, apiVersion and kind are used to locate a unique resource so they can't be empty")
	}

	// Locate the cluster resource and build config with it
	obj, err := r.Cluster.Status.Store.Get(ctx, resourceDetail.Cluster, &metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	clusterFromContext := obj.(*cluster.Cluster)
	klog.Infof("Cluster found: %s", clusterFromContext.Name)
	config, err := clusterstorage.NewConfigFromCluster(clusterFromContext)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to create cluster client config %s", clusterFromContext.Name)
	}

	// Create the dynamic client
	client, err := dynamic.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	return client, nil
}

// GetResourceRelationship returns a full graph that contains all the resources that are related to obj
func (r *REST) GetResourceRelationship(ctx context.Context, obj unstructured.Unstructured, relationshipGraph graph.Graph[string, RelationshipGraphNode], resourceGraph graph.Graph[string, ResourceGraphNode]) (graph.Graph[string, ResourceGraphNode], error) {
	client, err := r.BuildDynamicClient(ctx)
	if err != nil {
		panic(err.Error())
	}
	namespace := obj.GetNamespace()
	objName := obj.GetName()
	gv, _ := schema.ParseGroupVersion(obj.GetAPIVersion())
	objResourceNode := ResourceGraphNode{
		Group:     gv.Group,
		Version:   gv.Version,
		Kind:      obj.GetKind(),
		Name:      objName,
		Namespace: namespace,
	}
	resourceGraph.AddVertex(objResourceNode)

	objGVKOnGraph, _ := FindNodeOnGraph(relationshipGraph, gv.Group, gv.Version, obj.GetKind())
	// TODO: process error
	// Recursively find parents
	for _, objParent := range objGVKOnGraph.Parent {
		resourceGraph, err = GetParents(ctx, client, obj, objParent, namespace, objName, objResourceNode, relationshipGraph, resourceGraph)
		if err != nil {
			return nil, err
		}
	}

	// Recursively find children
	for _, objChild := range objGVKOnGraph.Children {
		resourceGraph, err = GetChildren(ctx, client, obj, objChild, namespace, objName, objResourceNode, relationshipGraph, resourceGraph)
		if err != nil {
			return nil, err
		}
	}

	return resourceGraph, nil
}

// InsertIfNotExist inserts relation into relationList only if it does not exist already
// This is used to auto-generate two-way relationships when they are not declared explicitly
func InsertIfNotExist(relationList []*Relationship, relation Relationship, relationshipDirection string) ([]*Relationship, error) {
	relationToInsert := &relation
	if relationshipDirection == "parent" {
		// Append parent-child relationship to child's parent also
		relationToInsert.Group = relation.ParentNode.Group
		relationToInsert.Version = relation.ParentNode.Version
		relationToInsert.Kind = relation.ParentNode.Kind
		relationToInsert.ParentNode = relation.ParentNode
		relationToInsert.ChildNode = relation.ChildNode
		relationToInsert.AutoGenerated = true
	} else if relationshipDirection == "child" {
		// Append parent-child relationship to parent's children also
		relationToInsert.Group = relation.ChildNode.Group
		relationToInsert.Version = relation.ChildNode.Version
		relationToInsert.Kind = relation.ChildNode.Kind
		relationToInsert.ParentNode = relation.ParentNode
		relationToInsert.ChildNode = relation.ChildNode
		relationToInsert.AutoGenerated = true
	}
	// Append only if the relationship does not exist already
	for _, r := range relationList {
		if RelationshipEquals(r, &relation) {
			klog.Infof("Relationship between %s and %s already exists. Skipping...", r.Kind, relation.Kind)
			return relationList, nil
		}
	}
	relationList = append(relationList, relationToInsert)
	return relationList, nil
}

// RelationshipEquals returns true if two relationships are equal
func RelationshipEquals(r, relation *Relationship) bool {
	return r.Group == relation.Group && r.Version == relation.Version && r.Kind == relation.Kind && r.Type == relation.Type && reflect.DeepEqual(r.JSONPath, relation.JSONPath)
}
