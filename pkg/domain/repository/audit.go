// Copyright The Karbour Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package repository

import (
	"bytes"
	"context"
	"encoding/json"

	"github.com/KusionStack/karbour/pkg/domain/model"
	"github.com/KusionStack/karbour/pkg/infra/persistence/elasticsearch"
)

const auditESIndex = "audit-index"

// AuditRepository defines the interface for audit log storage operations.
type AuditRepository interface {
	Create(ctx context.Context, audit model.Audit) error
	Update(ctx context.Context, audit model.Audit) error
	Read(ctx context.Context, auditID string) (model.Audit, error)
	Delete(ctx context.Context, auditID string) error
}

var _ AuditRepository = &esAuditRepository{}

type esAuditRepository struct {
	esClient elasticsearch.Client
	index    string // Elasticsearch index for storing audit logs
}

// NewESAuditRepository creates a new repository for Audit entities using Elasticsearch.
func NewESAuditRepository(client elasticsearch.Client) (AuditRepository, error) {
	if _, err := client.ExistIndex(context.TODO(), auditESIndex); err != nil {
		return nil, err
	}
	return &esAuditRepository{
		esClient: client,
		index:    auditESIndex,
	}, nil
}

// Create stores a new audit log entry in Elasticsearch.
func (r *esAuditRepository) Create(ctx context.Context, audit model.Audit) error {
	body, err := json.Marshal(audit)
	if err != nil {
		return err
	}

	// Assuming the audit log ID is generated by Elasticsearch
	return r.esClient.Save(ctx, r.index, audit.ID, bytes.NewReader(body))
}

// Read retrieves an audit log entry by its ID.
func (r *esAuditRepository) Read(ctx context.Context, auditID string) (model.Audit, error) {
	res, err := r.esClient.Get(ctx, r.index, auditID)
	if err != nil {
		return model.Audit{}, err
	}

	var audit model.Audit
	if err := json.Unmarshal(res.([]byte), &audit); err != nil {
		return model.Audit{}, err
	}

	return audit, nil
}

// Update modifies an existing audit log entry.
func (r *esAuditRepository) Update(ctx context.Context, audit model.Audit) error {
	body, err := json.Marshal(audit)
	if err != nil {
		return err
	}

	return r.esClient.Save(ctx, r.index, audit.ID, bytes.NewReader(body))
}

// Delete removes an audit log entry by its ID.
func (r *esAuditRepository) Delete(ctx context.Context, auditID string) error {
	return r.esClient.Delete(ctx, r.index, auditID)
}
